<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Colore: Corale.Colore.Native.Kernel32.NativeMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Colore
   &#160;<span id="projectnumber">5.1.0.99</span>
   </div>
   <div id="projectbrief">C# library for Razer&#39;s Chroma SDK</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pac-methods">Package Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Corale.Colore.Native.Kernel32.NativeMethods Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespace_corale_1_1_colore_1_1_native.html">Native</a> methods from <code>kernel32</code> module.  
 <a href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pac-methods"></a>
Package Functions</h2></td></tr>
<tr class="memitem:ad331a58d25fdba034d4858fc6c3d70f1"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#ad331a58d25fdba034d4858fc6c3d70f1">GetProcAddress</a> (IntPtr module, string procName)</td></tr>
<tr class="memdesc:ad331a58d25fdba034d4858fc6c3d70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).  <a href="#ad331a58d25fdba034d4858fc6c3d70f1">More...</a><br /></td></tr>
<tr class="separator:ad331a58d25fdba034d4858fc6c3d70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af588aa0a5c9fe039a5cf5c136d1569c4"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#af588aa0a5c9fe039a5cf5c136d1569c4">LoadLibrary</a> ([MarshalAs(UnmanagedType.LPStr)] string filename)</td></tr>
<tr class="memdesc:af588aa0a5c9fe039a5cf5c136d1569c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.  <a href="#af588aa0a5c9fe039a5cf5c136d1569c4">More...</a><br /></td></tr>
<tr class="separator:af588aa0a5c9fe039a5cf5c136d1569c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27744bbfb4aaa39b47de9e4d6eda30ff"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#a27744bbfb4aaa39b47de9e4d6eda30ff">GetCurrentProcess</a> ()</td></tr>
<tr class="memdesc:a27744bbfb4aaa39b47de9e4d6eda30ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pseudo handle for the current process.  <a href="#a27744bbfb4aaa39b47de9e4d6eda30ff">More...</a><br /></td></tr>
<tr class="separator:a27744bbfb4aaa39b47de9e4d6eda30ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601160d14a81b3352c299dd78ec81fe0"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#a601160d14a81b3352c299dd78ec81fe0">GetModuleHandle</a> (string moduleName)</td></tr>
<tr class="memdesc:a601160d14a81b3352c299dd78ec81fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a module handle for the specified module. The module must have been loaded by the calling process.  <a href="#a601160d14a81b3352c299dd78ec81fe0">More...</a><br /></td></tr>
<tr class="separator:a601160d14a81b3352c299dd78ec81fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede13f2aab1d0f0dd17e8101dc6dc4bc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#aede13f2aab1d0f0dd17e8101dc6dc4bc">IsWow64Process</a> ([In] IntPtr hProcess, [Out][MarshalAs(UnmanagedType.Bool)] out bool wow64Process)</td></tr>
<tr class="memdesc:aede13f2aab1d0f0dd17e8101dc6dc4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified process is running under WOW64.  <a href="#aede13f2aab1d0f0dd17e8101dc6dc4bc">More...</a><br /></td></tr>
<tr class="separator:aede13f2aab1d0f0dd17e8101dc6dc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7c01102d3d4ce4aad3409d14c294dae6"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html#a7c01102d3d4ce4aad3409d14c294dae6">DllName</a> = &quot;kernel32.dll&quot;</td></tr>
<tr class="memdesc:a7c01102d3d4ce4aad3409d14c294dae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the DLL from which functions are imported.  <a href="#a7c01102d3d4ce4aad3409d14c294dae6">More...</a><br /></td></tr>
<tr class="separator:a7c01102d3d4ce4aad3409d14c294dae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespace_corale_1_1_colore_1_1_native.html">Native</a> methods from <code>kernel32</code> module. </p>

<p>Definition at line <a class="el" href="_native_2_kernel32_2_native_methods_8cs_source.html#l00034">34</a> of file <a class="el" href="_native_2_kernel32_2_native_methods_8cs_source.html">NativeMethods.cs</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a27744bbfb4aaa39b47de9e4d6eda30ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr Corale.Colore.Native.Kernel32.NativeMethods.GetCurrentProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">package</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pseudo handle for the current process. </p>
<dl class="section return"><dt>Returns</dt><dd>The return value is a pseudo handle to the current process.</dd></dl>
<p>A pseudo handle is a special constant, currently <code>(HANDLE)-1</code>, that is interpreted as the current process handle. For compatibility with future operating systems, it is best to call <code>GetCurrentProcess</code> instead of hard-coding this constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is required. Pseudo handles are not inherited by child processes. </p>
<p>This handle has the <code>PROCESS_ALL_ACCESS</code> access right to the process object. For more information, see Process Security and Access Rights. </p>
<p><b>Windows Server 2003 and Windows XP:</b> This handle has the maximum access allowed by the security descriptor of the process to the primary token of the process. </p>
<p>A process can create a "real" handle to itself that is valid in the context of other processes, or that can be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the <code>DuplicateHandle</code> function. A process can also use the <code>OpenProcess</code> function to open a real handle to itself. </p>
<p>The pseudo handle need not be closed when it is no longer needed. Calling the <code>CloseHandle</code> function with a pseudo handle has no effect. If the pseudo handle is duplicated by <code>DuplicateHandle</code>, the duplicate handle must be closed. </p>

</div>
</div>
<a class="anchor" id="a601160d14a81b3352c299dd78ec81fe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr Corale.Colore.Native.Kernel32.NativeMethods.GetModuleHandle </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>moduleName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">package</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a module handle for the specified module. The module must have been loaded by the calling process. </p>
<p>To avoid the race conditions described in the Remarks section, use the <code>GetModuleHandleEx</code> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleName</td><td>The name of the loaded module (either a <code>.dll</code> or <code>.exe</code> file). If the file name extension is omitted, the default library extension&lt;c&gt;.dll is appended.The file name string can include a trailing point character (<code>.</code>) to indicate that the module name has no extension.The string does not have to specify a path. When specifying a path, be sure to use backslashes (<code>&lt;/c&gt;), not forward slashes(<code>/</code>). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process. </code></td></tr>
  </table>
  </dd>
</dl>
<p>If this parameter is <code>NULL</code>, <code>GetModuleHandle</code> returns a handle to the file used to create the calling process (<code>.exe</code> file). </p>
<p><code> </code></p>
<p><code> The <code>GetModuleHandle</code> function does not retrieve handles for modules that were loaded using the <code>LOAD_LIBRARY_AS_DATAFILE</code> flag.For more information, see&lt;c&gt; LoadLibraryEx</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">If the function succeeds, the return value is a handle to the specified module. </p>
<p class="enddd">If the function fails, the return value is <code>NULL</code>.To get extended error information, call <code>GetLastError</code>.</p>
</dd></dl>
<p>The returned handle is not global or inheritable. It cannot be duplicated or used by another process. </p>
<p>If <code>lpModuleName</code> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use side-by-side assemblies, or use <code>GetModuleHandleEx</code> to specify a memory location rather than a DLL name. </p>
<p>The <code>GetModuleHandle</code> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <code>FreeLibrary</code> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <code>GetModuleHandle</code> to the FreeLibrary function. Doing so can cause a DLL module to be unmapped prematurely. </p>
<p>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module than the one intended. </p>

</div>
</div>
<a class="anchor" id="ad331a58d25fdba034d4858fc6c3d70f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr Corale.Colore.Native.Kernel32.NativeMethods.GetProcAddress </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>procName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">package</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>A handle to the DLL module that contains the function or variable. The <code>LoadLibrary</code>, <code>LoadLibraryEx</code>, <code>LoadPackagedLibrary</code>, or <code>GetModuleHandle</code> function returns this handle. The <code>GetProcAddress</code> function does not retrieve addresses from modules that were loaded using the <code>LOAD_LIBRARY_AS_DATAFILE</code> flag. For more information, see <code>LoadLibraryEx</code>. </td></tr>
    <tr><td class="paramname">procName</td><td>The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is <code>NULL</code>.To get extended error information, call <code>GetLastError</code>. </dd></dl>
<p>The spelling and case of a function name pointed to by <code>lpProcName</code> must be identical to that in the <code>EXPORTS</code> statement of the source DLL's module-definition (<code>.def</code>) file. The exported names of functions may differ from the names you use when calling these functions in your code. This difference is hidden by macros used in the SDK header files. For more information, see Conventions for Function Prototypes. </p>
<p>The <code>lpProcName</code> parameter can identify the DLL function by specifying an ordinal value associated with the function in the <code>EXPORTS</code> statement. <code>GetProcAddress</code> verifies that the specified ordinal is in the range 1 through the highest ordinal value exported in the <code>.def</code> file. The function then uses the ordinal as an index to read the function's address from a function table. </p>
<p>If the <code>.def</code> file does not number the functions consecutively from <code>1</code> to <code>N</code> (where <code>N</code> is the number of exported functions), an error can occur where <code>GetProcAddress</code> returns an invalid, non-<code>NULL</code> address, even though there is no function with the specified ordinal. </p>
<p>If the function might not exist in the DLL module - for example, if the function is available only on Windows Vista but the application might be running on Windows XP - specify the function by name rather than by ordinal value and design your application to handle the case when the function is not available. </p>

</div>
</div>
<a class="anchor" id="aede13f2aab1d0f0dd17e8101dc6dc4bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Corale.Colore.Native.Kernel32.NativeMethods.IsWow64Process </td>
          <td>(</td>
          <td class="paramtype">[In] IntPtr&#160;</td>
          <td class="paramname"><em>hProcess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[MarshalAs(UnmanagedType.Bool)] out bool&#160;</td>
          <td class="paramname"><em>wow64Process</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">package</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified process is running under WOW64. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hProcess</td><td>A handle to the process.The handle must have the <code>PROCESS_QUERY_INFORMATION</code> or <code>PROCESS_QUERY_LIMITED_INFORMATION</code> access right. For more information, see Process Security and Access Rights. </td></tr>
  </table>
  </dd>
</dl>
<p><b>Windows Server 2003 and Windows XP:</b> The handle must have the <code>PROCESS_QUERY_INFORMATION</code> access right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wow64Process</td><td>A pointer to a value that is set to <code>TRUE</code> if the process is running under WOW64. If the process is running under 32-bit Windows, the value is set to <code>FALSE</code>. If the process is a 64-bit application running under 64-bit Windows, the value is also set to <code>FALSE</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">If the function succeeds, the return value is a nonzero value. </p>
<p class="enddd">If the function fails, the return value is zero. To get extended error information, call <code>GetLastError</code>.</p>
</dd></dl>
<p>To compile an application that uses this function, define <code>_WIN32_WINNT</code> as <code>0x0501</code> or later. For more information, see Using the Windows Headers. </p>

</div>
</div>
<a class="anchor" id="af588aa0a5c9fe039a5cf5c136d1569c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr Corale.Colore.Native.Kernel32.NativeMethods.LoadLibrary </td>
          <td>(</td>
          <td class="paramtype">[MarshalAs(UnmanagedType.LPStr)] string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">package</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the module. This can be either a library module (a <code>.dll</code> file) or an executable module (an <code>.exe</code> file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <code>LIBRARY</code> keyword in the module-definition (<code>.def</code>) file. </td></tr>
  </table>
  </dd>
</dl>
<p>If the string specifies a full path, the function searches only that path for the module. </p>
<p>If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. </p>
<p>If the function cannot find the module, the function fails. When specifying a path, be sure to use backslashes (<code>&lt;/c&gt;), not forward slashes (<code>/</code>). For more information about paths, see Naming a File or Directory. </code></p>
<p><code> </code></p>
<p><code> If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension <code>.dll</code> to the module name. To prevent the function from appending <code>.dll</code> to the module name, include a trailing point character (<code>.</code>) in the module name string. </code></p>
<p><code> </code></p>
<p><code> </p><dl class="section return"><dt>Returns</dt><dd><p class="startdd">If the function succeeds, the return value is a handle to the module. </p>
<p class="enddd">If the function fails, the return value is <code>NULL</code>.To get extended error information, call <code>GetLastError</code>.</p>
</dd></dl>
<p></code></p>
<p><code> </code></p>
<p><code> To enable or disable error messages displayed by the loader during DLL loads, use the <code>SetErrorMode</code> function. </code></p>
<p><code> <code>LoadLibrary</code> can be used to load a library module into the address space of the process and return a handle that can be used in <code>GetProcAddress</code> to get the address of a DLL function. <code>LoadLibrary</code> can also be used to load other executable modules. For example, the function can specify an .exe file to get a handle that can be used in <code>FindResource</code> or <code>LoadResource</code>. However, do not use <code>LoadLibrary</code> to run an .exe file. Instead, use the <code>CreateProcess</code> function. </code></p>
<p><code> </code></p>
<p><code> If the specified module is a DLL that is not already loaded for the calling process, the system calls the DLL's <code>DllMain</code> function with the <code>DLL_PROCESS_ATTACH</code> value. If <code>DllMain</code> returns <code>TRUE</code>, <code>LoadLibrary</code> returns a handle to the module. If <code>DllMain</code> returns <code>FALSE</code>, the system unloads the DLL from the process address space and <code>LoadLibrary</code> returns <code>NULL</code>. It is not safe to call <code>LoadLibrary</code> from <code>DllMain</code>. For more information, see the Remarks section in <code>DllMain</code>. </code></p>
<p><code> </code></p>
<p><code> Module handles are not global or inheritable. A call to <code>LoadLibrary</code> by one process does not produce a handle that another process can use — for example, in calling <code>GetProcAddress</code>. The other process must make its own call to <code>LoadLibrary</code> for the module before calling <code>GetProcAddress</code>. </code></p>
<p><code> </code></p>
<p><code> If lp&lt;c&gt;FileName</code> does not include a path and there is more than one loaded module with the same base name and extension, the function returns a handle to the module that was loaded first. </p>
<p>If no file name extension is specified in the lp&lt;c&gt;FileName parameter, the default library extension .dll is appended. However, the file name string can include a trailing point character (.) to indicate that the module name has no extension. When no path is specified, the function searches for loaded modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds. Otherwise, the function searches for the file. </p>
<p>The first directory searched is the directory containing the image file used to create the calling process (for more information, see the <code>CreateProcess</code> function). Doing this allows private dynamic-link library (DLL) files associated with a process to be found without adding the process's installed directory to the <code>PATH</code> environment variable. If a relative path is specified, the entire relative path is appended to every token in the DLL search path list. To load a module from a relative path without searching any other path, use <code>GetFullPathName</code> to get a nonrelative path and call <code>LoadLibrary</code> with the nonrelative path. For more information on the DLL search order, see Dynamic-Link Library Search Order. </p>
<p>The search path can be altered using the <code>SetDllDirectory</code> function. This solution is recommended instead of using <code>SetCurrentDirectory</code> or hard-coding the full path to the DLL. </p>
<p>If a path is specified and there is a redirection file for the application, the function searches for the module in the application's directory. If the module exists in the application's directory, <code>LoadLibrary</code> ignores the specified path and loads the module from the application's directory. If the module does not exist in the application's directory, <code>LoadLibrary</code> loads the module from the specified directory. For more information, see Dynamic Link Library Redirection. </p>
<p>If you call <code>LoadLibrary</code> with the name of an assembly without a path specification and the assembly is listed in the system compatible manifest, the call is automatically redirected to the side-by-side assembly. </p>
<p>The system maintains a per-process reference count on all loaded modules. Calling <code>LoadLibrary</code> increments the reference count. Calling the <code>FreeLibrary</code> or <code>FreeLibraryAndExitThread</code> function decrements the reference count. The system unloads a module when its reference count reaches zero or when the process terminates (regardless of the reference count). </p>
<p>Windows Server 2003 and Windows XP: The Visual C++ compiler supports a syntax that enables you to declare thread-local variables: <code>_declspec(thread)</code>. If you use this syntax in a DLL, you will not be able to load the DLL explicitly using <code>LoadLibrary</code> on versions of Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local storage functions instead of <code>_declspec(thread)</code>. For an example, see Using Thread Local Storage in a Dynamic Link Library. Security Remarks </p>
<p>Do not use the <code>SearchPath</code> function to retrieve a path to a DLL for a subsequent <code>LoadLibrary</code> call. The <code>SearchPath</code> function uses a different search order than <code>LoadLibrary</code> and it does not use safe process search mode unless this is explicitly enabled by calling <code>SetSearchPathMode</code> with <code>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</code>. Therefore, <code>SearchPath</code> is likely to first search the user’s current working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current working directory, the path retrieved by <code>SearchPath</code> will point to the malicious DLL, which <code>LoadLibrary</code> will then load. </p>
<p>Do not make assumptions about the operating system version based on a <code>LoadLibrary</code> call that searches for a DLL. If the application is running in an environment where the DLL is legitimately not present but a malicious version of the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended techniques described in Getting the System Version. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7c01102d3d4ce4aad3409d14c294dae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string Corale.Colore.Native.Kernel32.NativeMethods.DllName = &quot;kernel32.dll&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the DLL from which functions are imported. </p>

<p>Definition at line <a class="el" href="_native_2_kernel32_2_native_methods_8cs_source.html#l00039">39</a> of file <a class="el" href="_native_2_kernel32_2_native_methods_8cs_source.html">NativeMethods.cs</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Corale.Colore/Native/Kernel32/<a class="el" href="_native_2_kernel32_2_native_methods_8cs_source.html">NativeMethods.cs</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_corale.html">Corale</a></li><li class="navelem"><a class="el" href="namespace_corale_1_1_colore.html">Colore</a></li><li class="navelem"><a class="el" href="namespace_corale_1_1_colore_1_1_native.html">Native</a></li><li class="navelem"><a class="el" href="namespace_corale_1_1_colore_1_1_native_1_1_kernel32.html">Kernel32</a></li><li class="navelem"><a class="el" href="class_corale_1_1_colore_1_1_native_1_1_kernel32_1_1_native_methods.html">NativeMethods</a></li>
    <li class="footer">Generated on Fri Dec 2 2016 16:05:42 for Colore by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
